# Задание 4

## Условие

Разработать ассемблер и интерпретатор для учебной виртуальной машины
(УВМ). Система команд УВМ представлена далее.

Для ассемблера необходимо разработать читаемое представление команд
УВМ. Ассемблер принимает на вход файл с текстом исходной программы, путь к
которой задается из командной строки. Результатом работы ассемблера является
бинарный файл в виде последовательности байт, путь к которому задается из
командной строки. Дополнительный ключ командной строки задает путь к файлу-
логу, в котором хранятся ассемблированные инструкции в духе списков
“ключ=значение”, как в приведенных далее тестах.

Интерпретатор принимает на вход бинарный файл, выполняет команды УВМ
и сохраняет в файле-результате значения из диапазона памяти УВМ. Диапазон
также указывается из командной строки.

Форматом для файла-лога и файла-результата является **csv**.

Необходимо реализовать приведенные тесты для всех команд, а также
написать и отладить тестовую программу.

### Загрузка константы

| А        | B         | C          |
|----------|-----------|------------|
| Биты 0—2 | Биты 3—26 | Биты 27—33 |
| 0        | Константа | Адрес      |

Размер команды: 5 байт. Операнд: поле B. Результат: регистр по адресу,
которым является поле C.

    Тест (A=0, B=482, C=22):
    0x10, 0x0F, 0x00, 0xB0, 0x00

### Чтение из памяти

| А        | B        | C          |
|----------|----------|------------|
| Биты 0—2 | Биты 3—9 | Биты 10-34 |
| 0        | Адрес    | Адрес      |

Размер команды: 5 байт. Операнд: ячейка памяти по адресу, которым
является поле C. Результат: регистр по адресу, которым является поле B.

    Тест (A=7, B=45, C=310):
    0x6F, 0xD9, 0x04, 0x00, 0x00

### Запись в память

| A        | B        | C          | D          |
|----------|----------|------------|------------|
| Биты 0—2 | Биты 3—9 | Биты 10—16 | Биты 17—30 |
| 3        | Адрес    | Адрес      | Смещение   |

Размер команды: 4 байт. Операнд: регистр по адресу, которым является поле
B. Результат: ячейка памяти по адресу, которым является сумма адреса (регистр
по адресу, которым является поле C) и смещения (поле D).

    Тест (A=1, B=95, C=33, D=543):
    0xF9, 0x86, 0x3E, 0x04

### Бинарная операция: побитовое "или"

| A        | B         | C          | D          |
|----------|-----------|------------|------------|
| Биты 0—2 | Биты 3—16 | Биты 17—23 | Биты 24—30 |
| 3        | Смещение  | Адрес      | Адрес      |

Размер команды: 4 байт. Первый операнд: регистр по адресу, которым
является поле C. Второй операнд: ячейка памяти по адресу, которым является
сумма адреса (регистр по адресу, которым является поле D) и смещения (поле B).
Результат: регистр по адресу, которым является поле C.

    Тест (A=3, B=878, C=108, D=83):
    0x73, 0x1B, 0xD8, 0x53

---

## Реализация языка

### Загрузка константы

**Синтаксис:**

```asm
LOAD_CONSTANT <регистр>, #<значение>
```

**Описание:** Команда загружает константное значение в указанный регистр.

**Пример:**

```asm
LOAD_CONSTANT R0, #100
```

Запишет значение 100 в регистр R0.

### Запись в память

**Синтаксис:**

```asm
MEMORY_WRITE [<регистр1> + <сдвиг>], <регистр2>
```

**Описание:** Команда записывает данные из регистр2 в ячейку памяти, адрес которой вычисляется как сумма значения в
регистр1 и заданного сдвига.

**Пример:**

```asm
MEMORY_WRITE [R24 + 0], R8
```

Запишет значение из R8 в ячейку памяти по адресу [значение R24 + 0].

### Загрузка из памяти

**Синтаксис:**

```asm
MEMORY_READ <регистр>, [<адрес>]
```

**Описание:** Загружает значение из ячейки памяти по заданному адресу в указанный регистр.

**Пример:**

```asm
MEMORY_READ R45, [310]
```

Запишет значение из ячейки памяти по индексу 310 в регистр R45.

### Побитовое “или”

**Синтаксис:**

```asm
OR <регистр1>, [<регистр2> + <сдвиг>]
```

**Описание:** Команда выполняет побитовое “или” (OR) между значением в регистр1 и значением в ячейке памяти, адрес
которой определяется как [значение в регистр2 + сдвиг]. Результат сохраняется в регистр1.

**Пример:**

```asm
OR R0, [R24 + 0]
```

Выполняет операцию R0 = R0 | память[R24 + 0].

Хорошо, добавим более подробное описание для блока **Реализация ассемблера**, включая информацию о запуске ассемблера и
подробное описание ключевых функций и их назначения.

---
## Сборка
### Требования

	C++17 или новее.
	Компилятор, поддерживающий стандарт C++17 (например, GCC 9.3+, Clang 10+).
	Утилита CMake для сборки проекта (по желанию).

### Сборка проекта
1.	Клонируйте репозиторий:
```bash
   git clone https://github.com/Fallet666/kisscm.git
   cd kisscm/dz4
```
2.	Используйте CMake для сборки:
```bash
mkdir build
cd build
cmake ..
make
```

---
## Реализация ассемблера

Ассемблер состоит из трёх основных файлов:

### 1. `assembler.cpp`

Файл `assembler.cpp` является точкой входа в программу. Он принимает аргументы командной строки для запуска ассемблера и
вызывает нужные функции для обработки входного файла с инструкциями.

**Запуск ассемблера:**

Ассемблер запускается из командной строки с передачей трех обязательных аргументов:

- Путь к входному файлу с инструкциями на языке ассемблера.
- Путь к выходному файлу для записи скомпилированного бинарного кода.
- Путь к лог-файлу для записи информации об обработанных инструкциях.

Пример запуска:

```bash
./assembler ../files/input.asm ../files/output.bin ../files/log.csv
```

Здесь:

- `../files/input.asm` — путь к файлу с исходными инструкциями на языке.
- `../files/output.bin` — путь к файлу, в который будет записан бинарный код.
- `../files/log.csv` — путь к лог-файлу для записи данных о выполненных операциях.

**Основные действия `assembler.cpp`:**

1. Читает аргументы командной строки.
2. Инициализирует объект класса `Assemble` (из файла `Assemble.cpp`) и передает ему путь к входному файлу, выходному
   бинарному файлу и лог-файлу.
3. Запускает процесс преобразования ассемблерных команд в бинарный формат, а также записывает обработанные данные в
   лог-файл.

### 2. `Assemble.cpp`

`Assemble.cpp` — основной файл, где реализована логика ассемблера. Здесь находится класс `Assemble`, который отвечает за
обработку каждой команды языка, ее анализ и преобразование в бинарный формат. Функции файла работают с командами
`LOAD_CONSTANT`, `MEMORY_WRITE`, `MEMORY_READ`, `OR`.

**Основные функции `Assemble.cpp`:**

- **Конструктор класса `Assemble`:** загружает входные данные и инициализирует переменные для обработки команд.
- **Функция `parseInstruction`** — основная функция парсинга, которая анализирует каждую строку файла инструкций,
  определяет тип команды и вызывает соответствующую функцию для её обработки.
- **Функции для обработки команд:**
    - **`loadConstant`** — обрабатывает команду `LOAD_CONSTANT`:
        - Извлекает номер регистра и константу, указанную в инструкции.
        - Преобразует команду в бинарный формат и записывает её в выходной файл.
    - **`memoryWrite`** — обрабатывает команду `MEMORY_WRITE`:
        - Определяет адрес памяти с учётом регистра и сдвига, а также данные для записи.
        - Преобразует данные в бинарный формат и записывает их в выходной файл.
    - **`memoryRead`** — обрабатывает команду `MEMORY_READ`:
        - Считывает адрес памяти и копирует значение в указанный регистр.
        - Записывает информацию о процессе в бинарный файл и лог-файл.
    - **`bitwiseOr`** — обрабатывает команду `OR`:
        - Извлекает операнды, выполняет побитовое "или" и записывает результат в регистр.
        - Преобразует инструкцию в бинарный формат и записывает её в выходной файл.

**Пример обработки команды:**

Для команды `LOAD_CONSTANT R0, #100`:

- `loadConstant` идентифицирует `R0` как регистр и `100` как значение.
- Инструкция преобразуется в бинарный код с уникальным кодом операции для `LOAD_CONSTANT`.
- Код записывается в выходной бинарный файл, а данные о процессе — в лог-файл.

### 3. `Assemble.h`

`Assemble.h` содержит определения и описания всех функций и переменных класса `Assemble`, которые используются в
`Assemble.cpp`. Этот заголовочный файл позволяет другим модулям взаимодействовать с функциями класса `Assemble`,
обеспечивая удобство и модульность в разработке.

**Ключевые компоненты:**

- **Объявления функций:** здесь объявлены все функции для работы с командами, такие как `loadConstant`, `memoryWrite`,
  `memoryRead`, `bitwiseOr`.
- **Внутренние переменные класса:** хранят текущий статус инструкций, результаты парсинга и промежуточные данные для
  операций.

`Assemble.h` служит своего рода спецификацией для класса `Assemble` и содержит объявления переменных, которые
используются для хранения информации о текущих регистрах, данных и результирующих бинарных кодах.

---

## Реализация интерпретатора

Чтобы запустить интерпретатор, необходимо передать ему аргументы командной строки:

```
./interpreter <binaryFile> <resultFile> <start> <end>
```

где:

- `<binaryFile>` — путь к бинарному файлу с закодированными командами.
- `<resultFile>` — имя выходного CSV-файла, в который будут записаны значения памяти.
- `<start>` и `<end>` — индексы диапазона памяти, который будет сохранен в файл.

Пример запуска:

```bash
./interpreter ../files/output.bin ../files/memory_dump.csv 0 100
```

### Разбор функциональности

1. **Функция `main`**
    - Основная функция `main` проверяет корректность количества аргументов, принимает входные параметры, а затем
      вызывает функцию `Interpret`, которая загружает и обрабатывает команды из бинарного файла.

2. **Конструктор `Interpret`**
    - Конструктор интерпретатора `Interpret` инициализирует отладочный режим, открывает бинарный файл и последовательно
      считывает команды.
    - Каждая команда определяется по начальному типу (3 бита), на основе которых выбирается размер команды (32 или 40
      бит).
    - В зависимости от типа команды вызываются соответствующие функции декодирования и выполнения.

3. **Функции для выполнения команд**
    - **`loadConstantFromCode`**: загружает значение в регистр `C`, используя значение `B` из команды.
    - **`memoryReadFromCode`**: считывает значение из памяти по адресу `C` и сохраняет в регистре `B`.
    - **`memoryWriteFromCode`**: записывает значение из регистра `B` в память по адресу, заданному суммой регистра `C` и
      смещения `D`.
    - **`bitwiseOrFromCode`**: выполняет побитовое "или" с памятью, используя регистры `C`, `D` и смещение `B`.

4. **Отладочный вывод**
    - Функция `debugOutput` выводит текущее состояние регистров и первых 16 ячеек памяти после выполнения каждой
      команды, если включен отладочный режим.

5. **Сохранение памяти в CSV**
    - Функция `saveMemoryToCSV` записывает значения памяти в указанный файл `resultFile` в формате CSV, начиная с адреса
      `start` и до адреса `end`.

### Структура `Interpret.h`

Заголовочный файл `Interpret.h` определяет класс `Interpret`, хранящий память (`memory`) и регистры (`registers`) как
вектора `uint32_t`.
