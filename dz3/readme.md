# Учебный инструмент командной строки для преобразования JSON в учебный конфигурационный язык

### Введение

Данная программа представляет собой инструмент командной строки, предназначенный для преобразования входного JSON файла в текст на учебном конфигурационном языке. Входной текст JSON анализируется, и в случае синтаксических ошибок выводятся соответствующие сообщения. Поддерживается проверка допустимых ключей и синтаксиса выходного языка, включая объявление констант, работу с массивами и комментариями.

### Класс `Translator`

Класс `Translator` выполняет основную работу по преобразованию входного JSON в конфигурационный язык. Ниже приведено описание каждого метода класса.

#### Конструктор `Translator(const std::string &inputFile, const std::string &outputFile)`

Этот конструктор инициализирует преобразование, вызывая метод `readFile` для чтения JSON содержимого из `inputFile`, затем парсит его с использованием `json::parse`, конвертирует в конфигурационный текст с помощью `jsonToConfig`, и записывает результат в `outputFile`.

**Аргументы:**
- `inputFile`: Путь к входному JSON файлу.
- `outputFile`: Путь к выходному файлу конфигурационного языка.

**Обработка ошибок**:
В случае ошибки парсинга или ввода-вывода выбрасывается исключение, которое перехватывается и выводится в `stderr`.

#### `bool keyValidator(const std::string &key)`

Метод проверяет, соответствует ли ключ правилам именования: он должен состоять из строчных букв и символа подчеркивания `_`.

**Аргументы:**
- `key`: Ключ для проверки.

**Возвращает**: `true`, если ключ валиден, иначе — `false`.

#### `std::string jsonToConfig(const json::value &jv)`

Метод `jsonToConfig` рекурсивно обрабатывает JSON объект, создавая строку конфигурационного языка.

1. Если ключ `comment`, то метод формирует однострочный или многострочный комментарий.
2. Если значение является числом, создается объявление константы.
3. Если значение является массивом, то ключ формируется как массив `array(...)`, с поддержкой целых чисел.

**Аргументы:**
- `jv`: JSON объект для преобразования.

**Возвращает**: Сформированную строку конфигурационного языка.

#### `std::string readFile(const std::string &filename)`

Метод считывает содержимое файла в строку.

**Аргументы:**
- `filename`: Путь к файлу.

**Возвращает**: Содержимое файла в виде строки.

#### `void writeFile(const std::string &filename, const std::string &content)`

Метод записывает строку `content` в файл `filename`.

**Аргументы:**
- `filename`: Путь к файлу.
- `content`: Содержимое для записи.

---

### Основная функция `main`

Функция `main` управляет общим процессом выполнения программы, проверяя наличие аргументов командной строки:

1. **Аргументы командной строки**: Ожидает два аргумента — входной JSON файл и выходной конфигурационный файл. Если их меньше, выводит сообщение об ошибке.
2. **Создание экземпляра `Translator`**: Экземпляр создается с использованием путей, указанных в аргументах командной строки.

### Пример использования

#### Входной JSON файл (`input.json`)

```json
{
  "comment": "This is a configuration example",
  "variable1": 42,
  "variable2": [1, 2, 3]
}
```

#### Результат в конфигурационном языке (`output.config`)

```plaintext
// This is a configuration example
var variable1 := 42
var variable2 := array( 1, 2, 3 )
```

### Системные требования и зависимости

Для сборки и выполнения программы требуются следующие компоненты:

1. **Компилятор C++**: Поддерживающий стандарт C++17 и выше.
2. **Библиотека Boost.JSON**: Используется для парсинга JSON файлов.
3. **CMake** (опционально): Для удобства сборки проекта.

---

### Заключение

Программа разработана для преобразования JSON в конфигурационный язык, предоставляя понятные сообщения об ошибках и удобную структуру кода для поддержки расширяемости.